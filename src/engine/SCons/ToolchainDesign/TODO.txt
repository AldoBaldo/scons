To Do:

Tools:
 * DONE tool as class
 * tool as module (on toolpath)
 * tool as callable
 * toolpath
 * init_kw and call_kw (see Tool/__init__.py)
 * Should a Tool have a missing() call to set up something
   in the env to indicate the tool is missing?
   E.g. env['CC'] = 'MissingCCTool' or even throw an exception
 * OR: should it simply create its Builder(s) to throw an exception?
   (This might be hard with how Program and Object etc. work now)
 * exists() must be True/False, not return a tuple
   (or return something testable as True/False)
 * XXX: if a Tool defines a single Builder, instances with different
   args will redefine the same Builder rather than different Builders,
   so the args don't really work.  Tools need to make different
   Builders somehow.  Need to figure this out!


Toolchain:
 * DONE simple chains
 * DONE AND chains
 * DONE OR chains
 * DONE Optional elements
 * ANY chains? (just use Optional?)
 * GeneratorToolchain - callback that returns tool list
 * Query if tool (a) has been registered and/or (b) exists (without registering it)
 * error handling

Questions:
 * should exists and/or generate be methods on Tool that redirect to
   the actual ones, or can the returned Tool subclass just be used
   directly?  Another way to look at it: should Tool be a container
   for the real tool, or should the real tool be a subclass of Tool?
 * How can a user (SConstruct author or Tool author) modify existing
   toolchains to add their tool or add/subtract tools from default lists?
 * Should there be some Tool-subsystem-global configuration?
   - OS, ARCH etc.?
   - (default) PATH to use to find executables?
   If so, where should it live?  Base Tool class?
